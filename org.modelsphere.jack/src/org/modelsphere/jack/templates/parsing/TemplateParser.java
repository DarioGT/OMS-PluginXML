/* Generated By:JavaCC: Do not edit this line. TemplateParser.java */
package org.modelsphere.jack.templates.parsing;

import org.modelsphere.jack.srtool.forward.CharacterDomain;
import org.modelsphere.jack.srtool.forward.BooleanModifier;
import org.modelsphere.jack.srtool.forward.IntegerModifier;
import org.modelsphere.jack.templates.TemplateActions;

public class TemplateParser implements TemplateParserConstants {

    private static TemplateActions m_actions = null;

    public static void main(String args[]) throws ParseException {
        TemplateParser parser = new TemplateParser(System.in);
        parser.Input();
    }

    public static void setActions(TemplateActions actions) {
        m_actions = actions;
    }

    /*
     * ENTRY POINT
     */
    static final public void Input() throws ParseException {
        int count = 0;
        m_actions.beginningOfFile();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IMPORT:
            optional_import_clause();
            break;
        default:
            jj_la1[0] = jj_gen;
            ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case NEW:
            variable_decl_list();
            break;
        default:
            jj_la1[1] = jj_gen;
            ;
        }
        rule_decl_list();
        jj_consume_token(0);
        m_actions.endOfFile();
    }

    /*
     * OPTIONAL IMPORT CLAUSE
     */
    static final public void optional_import_clause() throws ParseException {
        String classfile;
        jj_consume_token(IMPORT);
        classfile = string_literal();
        m_actions.processImportClause(classfile);
        end_of_decl();
    }

    /*
     * VARIABLE DECLARATIONS Example: NEW STRING var0; Example: NEW BOOLEAN cond = TRUE;
     */
    static final public void variable_decl_list() throws ParseException {
        variable_decl();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case NEW:
            variable_decl_list();
            break;
        default:
            jj_la1[2] = jj_gen;
            ;
        }
    }

    static final public void variable_decl() throws ParseException {
        jj_consume_token(NEW);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case BOOLEAN:
        case EXTERN:
            boolean_variable_decl();
            break;
        case INTEGER:
            integer_variable_decl();
            break;
        case STRING:
            string_variable_decl();
            break;
        case LIST:
            list_variable_decl();
            break;
        default:
            jj_la1[3] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        end_of_decl();
    }

    static final public void boolean_variable_decl() throws ParseException {
        Token token;
        String id;
        Object value;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case EXTERN:
            extern_qual();
            break;
        default:
            jj_la1[4] = jj_gen;
            ;
        }
        token = jj_consume_token(BOOLEAN);
        id = identifier();
        jj_consume_token(112);
        value = boolean_expression();
        m_actions.processVariableDeclaration(id, token.image, value);
    }

    static final public void integer_variable_decl() throws ParseException {
        Token t;
        String id;
        Object value = null;
        t = jj_consume_token(INTEGER);
        id = identifier();
        jj_consume_token(112);
        value = integer_expression();
        m_actions.processVariableDeclaration(id, t.image, value);
    }

    static final public void string_variable_decl() throws ParseException {
        Token t;
        String id, value = null;
        t = jj_consume_token(STRING);
        id = identifier();
        jj_consume_token(112);
        value = string_literal_token();
        m_actions.processVariableDeclaration(id, t.image, value);
    }

    static final public void list_variable_decl() throws ParseException {
        Token t;
        String id;
        t = jj_consume_token(LIST);
        id = identifier();
        jj_consume_token(112);
        jj_consume_token(NULL);
        m_actions.processVariableDeclaration(id, t.image, null);
    }

    static final public String boolean_value() throws ParseException {
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case TRUE:
            t = jj_consume_token(TRUE);
            break;
        case FALSE:
            t = jj_consume_token(FALSE);
            break;
        default:
            jj_la1[5] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true)
                return t.image;
        }
        throw new Error("Missing return statement in function");
    }

    /*
     * RULE DECLARATIONS Example: templ TEMPL "$subTemplate;";
     */
    static final public void rule_decl_list() throws ParseException {
        rule_decl();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IDENTIFIER:
            rule_decl_list();
            break;
        default:
            jj_la1[6] = jj_gen;
            ;
        }
    }

    static final public void decl_name() throws ParseException {
        Token name;
        name = jj_consume_token(IDENTIFIER);
        m_actions.processDeclName(name.image);
    }

    static final public void rule_decl() throws ParseException {
        decl_name();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case ADD:
            add_decl();
            break;
        case ATTR:
            attr_decl();
            break;
        case CDOM:
            cdom_decl();
            break;
        case CLEAR:
            clear_decl();
            break;
        case COND:
            cond_decl();
            break;
        case CONN:
            conn_decl();
            break;
        case FOREACH:
            foreach_decl();
            break;
        case GET:
            get_decl();
            break;
        case GROUP:
            group_decl();
            break;
        case IDOM:
            idom_decl();
            break;
        case SET:
            set_decl();
            break;
        case TEMPL:
            templ_decl();
            break;
        case PLUGIN:
            pluginfn_decl();
            break;
        case USERCONN:
            userconn_decl();
            break;
        default:
            jj_la1[7] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
    }

    static final public void end_of_decl() throws ParseException {
        m_actions.endOfDecl();
        jj_consume_token(113);
    }

    /* String processing */
    static final public String string_literal_token() throws ParseException {
        Token t;
        t = jj_consume_token(STRING_LITERAL);
        {
            if (true)
                return t.image;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String string_literal() throws ParseException {
        String s1, s2 = "";
        s1 = string_literal_token();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case STRING_LITERAL:
            s2 = string_literal();
            break;
        default:
            jj_la1[8] = jj_gen;
            ;
        }
        {
            if (true)
                return s1 + s2;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String identifier() throws ParseException {
        Token t;
        t = jj_consume_token(IDENTIFIER);
        {
            if (true)
                return t.image;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String identifier_or_literal() throws ParseException {
        String s;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IDENTIFIER:
            s = identifier();
            break;
        case STRING_LITERAL:
            s = string_literal();
            break;
        default:
            jj_la1[9] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true)
                return s;
        }
        throw new Error("Missing return statement in function");
    }

    /* ADD TO A LIST */
    static final public void add_decl() throws ParseException {
        String varname = null;
        Object value = null;
        jj_consume_token(ADD);
        jj_consume_token(114);
        varname = identifier();
        jj_consume_token(115);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case STRING_LITERAL:
        case STRING:
        case COMPUTE:
        case TOINTEGER:
        case TOSTRING:
        case IDENTIFIER:
            value = string_set_decl_value();
            break;
        case BOOLEAN:
        case BOTH:
        case CONTAINS:
        case EITHER:
        case FALSE:
        case IF:
        case INSTANCEOF:
        case NOT:
        case ONLYCONTAINS:
        case STARTSWITH:
        case TRUE:
            value = boolean_set_decl_value();
            break;
        case INTEGER_LITERAL:
        case INTEGER:
        case ADD:
        case DIVIDE:
        case LENGTH:
        case MULTIPLY:
        case SUBSTRACT:
        case 118:
            value = integer_set_decl_value();
            break;
        default:
            jj_la1[10] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        jj_consume_token(116);
        m_actions.processAddToList(varname, value);
        end_of_decl();
    }

    /* ATTRIBUTE */
    static final public void attr_decl() throws ParseException {
        String s;
        jj_consume_token(ATTR);
        s = identifier_or_literal();
        m_actions.processAttribute(s);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case DOM:
        case LOWER:
        case NULL:
        case PREF:
        case SUF:
        case UPPER:
        case 115:
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 115:
                jj_consume_token(115);
                break;
            default:
                jj_la1[11] = jj_gen;
                ;
            }
            attr_qualifier_list();
            break;
        default:
            jj_la1[12] = jj_gen;
            ;
        }
        end_of_decl();
    }

    static final public void pluginfn_decl() throws ParseException {
        Token t;
        jj_consume_token(PLUGIN);
        jj_consume_token(FUNCTION);
        t = jj_consume_token(IDENTIFIER);
        m_actions.processUserFn(t.image);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case CHILD:
            child_qual();
            break;
        default:
            jj_la1[13] = jj_gen;
            ;
        }
        end_of_decl();
    }

    static final public void attr_qualifier_list() throws ParseException {
        attr_qualifier();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case DOM:
        case LOWER:
        case NULL:
        case PREF:
        case SUF:
        case UPPER:
            attr_qualifier_list();
            break;
        default:
            jj_la1[14] = jj_gen;
            ;
        }
    }

    static final public void attr_qualifier() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case DOM:
            dom_qual();
            break;
        case NULL:
            null_qual();
            break;
        case PREF:
            pref_qual();
            break;
        case SUF:
            suf_qual();
            break;
        case UPPER:
            upper_qual();
            break;
        case LOWER:
            lower_qual();
            break;
        default:
            jj_la1[15] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
    }

    /* CHARACTER DOMAINS */
    static final public void cdom_decl() throws ParseException {
        Token t = null;
        String s = null;
        jj_consume_token(CDOM);
        m_actions.processCharacterDomain();
        character_domain_clause_list();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case NOCASE:
            t = jj_consume_token(NOCASE);
            break;
        default:
            jj_la1[16] = jj_gen;
            ;
        }
        if (t != null) {
            s = t.image;
        }
        m_actions.processNoCaseQual(s);
        end_of_decl();
    }

    static final public void character_domain_clause_list() throws ParseException {
        jj_consume_token(114);
        character_domain_clause();
        jj_consume_token(116);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 114:
            character_domain_clause_list();
            break;
        default:
            jj_la1[17] = jj_gen;
            ;
        }
    }

    static final public void character_domain_clause() throws ParseException {
        Token t = null;
        String s;
        s = character_domain_value_list();
        jj_consume_token(115);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IDENTIFIER:
            t = jj_consume_token(IDENTIFIER);
            break;
        case STRING_LITERAL:
            t = jj_consume_token(STRING_LITERAL);
            break;
        default:
            jj_la1[18] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        m_actions.processCharacterDomainClause(s, t.image);
    }

    static final public String character_domain_value_list() throws ParseException {
        String s = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case STRING_LITERAL:
        case _DEFAULT:
            s = character_domain_value();
            break;
        case 114:
            jj_consume_token(114);
            s = string_literal_list();
            jj_consume_token(116);
            break;
        default:
            jj_la1[19] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true)
                return s;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String default_kw() throws ParseException {
        jj_consume_token(_DEFAULT);
        {
            if (true)
                return "\"" + CharacterDomain.DEFAULT_STRING + "\"";
        }
        throw new Error("Missing return statement in function");
    }

    static final public String null_kw() throws ParseException {
        jj_consume_token(NULL);
        {
            if (true)
                return "\"" + CharacterDomain.NULL_STRING + "\"";
        }
        throw new Error("Missing return statement in function");
    }

    /* Note: NULL no longer valid in a CDOM clause */
    static final public String character_domain_value() throws ParseException {
        String s = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case STRING_LITERAL:
            s = string_literal();
            break;
        case _DEFAULT:
            s = default_kw();
            break;
        default:
            jj_la1[20] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true)
                return s;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String string_literal_list() throws ParseException {
        String s1, s2 = null;
        s1 = string_literal();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 115:
            jj_consume_token(115);
            s2 = string_literal_list();
            break;
        default:
            jj_la1[21] = jj_gen;
            ;
        }
        if (s2 != null) {
            s1 += "," + s2;
        }
        {
            if (true)
                return s1;
        }
        throw new Error("Missing return statement in function");
    }

    /* CLEAR A LIST */
    static final public void clear_decl() throws ParseException {
        String id;
        jj_consume_token(CLEAR);
        jj_consume_token(114);
        id = identifier();
        jj_consume_token(116);
        m_actions.processClearList(id);
        end_of_decl();
    }

    /* CONDITIONS */
    static final public void cond_decl() throws ParseException {
        BooleanModifier bm;
        jj_consume_token(COND);
        bm = boolean_expression();
        m_actions.processCondition(bm);
        true_and_or_false();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case NULL:
        case PREF:
        case SEP:
        case SUF:
            cond_qualifier_list();
            break;
        default:
            jj_la1[22] = jj_gen;
            ;
        }
        end_of_decl();
    }

    static final public void true_and_or_false() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case TRUE:
            true_qual();
            break;
        default:
            jj_la1[23] = jj_gen;
            ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case FALSE:
            false_qual();
            break;
        default:
            jj_la1[24] = jj_gen;
            ;
        }
    }

    static final public void cond_qualifier_list() throws ParseException {
        cond_qualifier();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case NULL:
        case PREF:
        case SEP:
        case SUF:
            cond_qualifier_list();
            break;
        default:
            jj_la1[25] = jj_gen;
            ;
        }
    }

    static final public void cond_qualifier() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case NULL:
            null_qual();
            break;
        case PREF:
            pref_qual();
            break;
        case SEP:
            sep_qual();
            break;
        case SUF:
            suf_qual();
            break;
        default:
            jj_la1[26] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
    }

    /* CONNECTORS */
    static final public void conn_decl() throws ParseException {
        String s;
        jj_consume_token(CONN);
        s = identifier_or_literal();
        m_actions.processConnector(s);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 115:
            jj_consume_token(115);
            break;
        default:
            jj_la1[27] = jj_gen;
            ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case WHEN:
            when_clause();
            break;
        default:
            jj_la1[28] = jj_gen;
            ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IFONECHILD:
            onechild_clause();
            break;
        case CHILD:
            child_qual();
            break;
        default:
            jj_la1[29] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case NULL:
        case PREF:
        case SEP:
        case SUF:
            conn_qualifier_list();
            break;
        default:
            jj_la1[30] = jj_gen;
            ;
        }
        end_of_decl();
    }

    static final public void userconn_decl() throws ParseException {
        Token t;
        jj_consume_token(USERCONN);
        t = jj_consume_token(IDENTIFIER);
        m_actions.processUserConnector(t.image);
        jj_consume_token(115);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IFONECHILD:
            onechild_clause();
            break;
        case CHILD:
            child_qual();
            break;
        default:
            jj_la1[31] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        end_of_decl();
    }

    static final public void when_clause() throws ParseException {
        BooleanModifier bm;
        jj_consume_token(WHEN);
        bm = boolean_expression();
        m_actions.processWhenCondition(bm);
    }

    static final public void onechild_clause() throws ParseException {
        String s;
        jj_consume_token(IFONECHILD);
        jj_consume_token(112);
        s = identifier_or_literal();
        m_actions.processOneChildQual(s);
        jj_consume_token(ELSE);
        child_qual();
    }

    static final public void conn_qualifier_list() throws ParseException {
        conn_qualifier();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case NULL:
        case PREF:
        case SEP:
        case SUF:
            conn_qualifier_list();
            break;
        default:
            jj_la1[32] = jj_gen;
            ;
        }
    }

    static final public void conn_qualifier() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case NULL:
            null_qual();
            break;
        case PREF:
            pref_qual();
            break;
        case SEP:
            sep_qual();
            break;
        case SUF:
            suf_qual();
            break;
        default:
            jj_la1[33] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
    }

    /* FOR EACH */
    static final public void foreach_decl() throws ParseException {
        String iter;
        Token t = null;
        jj_consume_token(FOREACH);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case DUPLICATED:
        case UNIQUE:
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case DUPLICATED:
                t = jj_consume_token(DUPLICATED);
                break;
            case UNIQUE:
                t = jj_consume_token(UNIQUE);
                break;
            default:
                jj_la1[34] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
            break;
        default:
            jj_la1[35] = jj_gen;
            ;
        }
        iter = identifier();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case FROM:
            foreach_iteration(iter);
            break;
        case IN:
            foreach_enumeration(iter, t);
            break;
        default:
            jj_la1[36] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
    }

    static final public void foreach_iteration(String iter) throws ParseException {
        IntegerModifier start, end;
        jj_consume_token(FROM);
        start = integer_expression();
        jj_consume_token(TO);
        end = integer_expression();
        child_qual();
        m_actions.processForEach(iter, start, end);
        end_of_decl();
    }

    static final public void foreach_enumeration(String iter, Token t) throws ParseException {
        String listname;
        jj_consume_token(IN);
        listname = identifier();
        child_qual();
        String s = (t == null) ? null : t.image;
        m_actions.processForEach(iter, listname, s);
        end_of_decl();
    }

    /* GROUPS */
    static final public void group_decl() throws ParseException {
        String s;
        jj_consume_token(GROUP);
        jj_consume_token(114);
        s = templ_list();
        jj_consume_token(116);
        m_actions.processGroup(s);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case EXTERN:
        case NULL:
        case PREF:
        case SEP:
        case SUF:
            group_qualifier_list();
            break;
        default:
            jj_la1[37] = jj_gen;
            ;
        }
        end_of_decl();
    }

    static final public String templ_list() throws ParseException {
        String s1, s2 = null;
        s1 = identifier();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 115:
            jj_consume_token(115);
            s2 = templ_list();
            break;
        default:
            jj_la1[38] = jj_gen;
            ;
        }
        if (s2 != null) {
            s1 += "," + s2;
        }

        {
            if (true)
                return s1;
        }
        throw new Error("Missing return statement in function");
    }

    static final public void group_qualifier_list() throws ParseException {
        group_qualifier();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case EXTERN:
        case NULL:
        case PREF:
        case SEP:
        case SUF:
            group_qualifier_list();
            break;
        default:
            jj_la1[39] = jj_gen;
            ;
        }
    }

    static final public void group_qualifier() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case EXTERN:
            extern_qual();
            break;
        case NULL:
            null_qual();
            break;
        case PREF:
            pref_qual();
            break;
        case SEP:
            sep_qual();
            break;
        case SUF:
            suf_qual();
            break;
        default:
            jj_la1[40] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
    }

    /* INTEGER DOMAINS */
    static final public void idom_decl() throws ParseException {
        jj_consume_token(IDOM);
        m_actions.processIntegerDomain();
        integer_domain_clause_list();
        end_of_decl();
    }

    static final public void integer_domain_clause_list() throws ParseException {
        integer_domain_clause();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 114:
            integer_domain_clause_list();
            break;
        default:
            jj_la1[41] = jj_gen;
            ;
        }
    }

    static final public void integer_domain_clause() throws ParseException {
        Token t1 = null, t2 = null;
        jj_consume_token(114);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INTEGER_LITERAL:
            t1 = jj_consume_token(INTEGER_LITERAL);
            break;
        case _DEFAULT:
            t1 = jj_consume_token(_DEFAULT);
            break;
        case NULL:
            t1 = jj_consume_token(NULL);
            break;
        default:
            jj_la1[42] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        jj_consume_token(115);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IDENTIFIER:
            t2 = jj_consume_token(IDENTIFIER);
            break;
        case STRING_LITERAL:
            t2 = jj_consume_token(STRING_LITERAL);
            break;
        default:
            jj_la1[43] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        jj_consume_token(116);
        String s1 = (t1 == null) ? null : t1.image;
        String s2 = (t2 == null) ? null : t2.image;
        m_actions.processIntegerDomainClause(s1, s2);
    }

    /* SET */
    static final public void set_decl() throws ParseException {
        String variable;
        Object value = null;
        jj_consume_token(SET);
        jj_consume_token(114);
        variable = identifier();
        jj_consume_token(115);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case STRING_LITERAL:
        case STRING:
        case COMPUTE:
        case TOINTEGER:
        case TOSTRING:
        case IDENTIFIER:
            value = string_set_decl_value();
            break;
        case BOOLEAN:
        case BOTH:
        case CONTAINS:
        case EITHER:
        case FALSE:
        case IF:
        case INSTANCEOF:
        case NOT:
        case ONLYCONTAINS:
        case STARTSWITH:
        case TRUE:
            value = boolean_set_decl_value();
            break;
        case INTEGER_LITERAL:
        case INTEGER:
        case ADD:
        case DIVIDE:
        case LENGTH:
        case MULTIPLY:
        case SUBSTRACT:
        case 118:
            value = integer_set_decl_value();
            break;
        default:
            jj_la1[44] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        jj_consume_token(116);
        m_actions.processSetStatement(variable, value);
        end_of_decl();
    }

    static final public String string_set_decl_value() throws ParseException {
        String val = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case IDENTIFIER:
            val = set_decl_rule_value();
            break;
        case STRING_LITERAL:
            val = string_set_decl_literal_value();
            break;
        case STRING:
            val = string_set_decl_variable_value();
            break;
        case TOINTEGER:
        case TOSTRING:
            val = set_decl_convert_value();
            break;
        case COMPUTE:
            val = set_decl_compute_value();
            break;
        default:
            jj_la1[45] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true)
                return val;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanModifier boolean_set_decl_value() throws ParseException {
        BooleanModifier bm = null;
        bm = boolean_expression();
        {
            if (true)
                return bm;
        }
        throw new Error("Missing return statement in function");
    }

    static final public IntegerModifier integer_set_decl_value() throws ParseException {
        IntegerModifier im = null;
        im = integer_expression();
        {
            if (true)
                return im;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String set_decl_rule_value() throws ParseException {
        Token t;
        String value;
        value = identifier();
        {
            if (true)
                return "RULE=" + value;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String string_set_decl_literal_value() throws ParseException {
        String value;
        value = string_literal();
        {
            if (true)
                return value;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String string_set_decl_variable_value() throws ParseException {
        String value;
        jj_consume_token(STRING);
        jj_consume_token(114);
        value = identifier();
        jj_consume_token(116);
        {
            if (true)
                return value;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String set_decl_convert_value() throws ParseException {
        Token t;
        String value;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case TOSTRING:
            t = jj_consume_token(TOSTRING);
            break;
        case TOINTEGER:
            t = jj_consume_token(TOINTEGER);
            break;
        default:
            jj_la1[46] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        jj_consume_token(114);
        value = identifier();
        jj_consume_token(116);
        {
            if (true)
                return t.image + "=" + value;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String set_decl_compute_value() throws ParseException {
        Token t;
        String s;
        t = jj_consume_token(COMPUTE);
        jj_consume_token(114);
        s = expr();
        jj_consume_token(116);
        {
            if (true)
                return t.image + "=" + s;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String expr() throws ParseException {
        Token t1 = null, t2 = null;
        String expr;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INTEGER_LITERAL:
        case IDENTIFIER:
            expr = operation();
            break;
        case 114:
            t1 = jj_consume_token(114);
            expr = expr();
            t2 = jj_consume_token(116);
            break;
        default:
            jj_la1[47] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        if (t1 == null) {
            {
                if (true)
                    return expr;
            }
        } else {
            {
                if (true)
                    return "(" + expr + ")";
            }
        }
        throw new Error("Missing return statement in function");
    }

    static final public String operation() throws ParseException {
        String t1, op = null, t2 = null;
        t1 = term();
        label_1: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case 117:
            case 118:
            case 119:
            case 120:
                ;
                break;
            default:
                jj_la1[48] = jj_gen;
                break label_1;
            }
            op = operator();
            t2 = term();
        }
        if (op == null) {
            {
                if (true)
                    return t1;
            }
        } else {
            {
                if (true)
                    return t1 + op + t2;
            }
        }
        throw new Error("Missing return statement in function");
    }

    static final public String term() throws ParseException {
        String s = null;
        Token t = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case INTEGER_LITERAL:
            t = jj_consume_token(INTEGER_LITERAL);
            break;
        case IDENTIFIER:
            s = identifier();
            break;
        default:
            jj_la1[49] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true)
                return (s != null) ? s : t.image;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String operator() throws ParseException {
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 117:
            t = jj_consume_token(117);
            break;
        case 118:
            t = jj_consume_token(118);
            break;
        case 119:
            t = jj_consume_token(119);
            break;
        case 120:
            t = jj_consume_token(120);
            break;
        default:
            jj_la1[50] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true)
                return t.image;
        }
        throw new Error("Missing return statement in function");
    }

    /* GET */
    static final public void get_decl() throws ParseException {
        String variable;
        jj_consume_token(GET);
        jj_consume_token(114);
        variable = identifier();
        jj_consume_token(116);
        m_actions.processGetStatement(variable);
        end_of_decl();
    }

    /* TEMPLATES */
    static final public void templ_decl() throws ParseException {
        String s;
        jj_consume_token(TEMPL);
        s = string_literal();
        m_actions.processTemplate(s);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case DOM:
        case EXTERN:
        case FILE:
        case LOWER:
        case NULL:
        case PREF:
        case SUF:
        case UPPER:
            templ_qualifier_list();
            break;
        default:
            jj_la1[51] = jj_gen;
            ;
        }
        end_of_decl();
    }

    static final public void templ_qualifier_list() throws ParseException {
        templ_qualifier();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case DOM:
        case EXTERN:
        case FILE:
        case LOWER:
        case NULL:
        case PREF:
        case SUF:
        case UPPER:
            templ_qualifier_list();
            break;
        default:
            jj_la1[52] = jj_gen;
            ;
        }
    }

    static final public void templ_qualifier() throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case DOM:
            dom_qual();
            break;
        case EXTERN:
            extern_qual();
            break;
        case FILE:
            file_qual();
            break;
        case NULL:
            null_qual();
            break;
        case PREF:
            pref_qual();
            break;
        case SUF:
            suf_qual();
            break;
        case UPPER:
            upper_qual();
            break;
        case LOWER:
            lower_qual();
            break;
        default:
            jj_la1[53] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
    }

    /* QUALIFIERS */
    static final public void attr_qual() throws ParseException {
        Token t;
        jj_consume_token(ATTR);
        jj_consume_token(112);
        t = jj_consume_token(IDENTIFIER);
        m_actions.processAttrQual(t.image);
    }

    static final public String child_kw() throws ParseException {
        Token t;
        t = jj_consume_token(CHILD);
        {
            if (true)
                return t.image;
        }
        throw new Error("Missing return statement in function");
    }

    static final public void child_qual() throws ParseException {
        String child, s;
        child = child_kw();
        jj_consume_token(112);
        s = identifier_or_literal();
        m_actions.processChildQual(child, s);
    }

    static final public void dom_qual() throws ParseException {
        Token t;
        jj_consume_token(DOM);
        jj_consume_token(112);
        t = jj_consume_token(IDENTIFIER);
        m_actions.processDomQual(t.image);
    }

    static final public void extern_qual() throws ParseException {
        String s = null;
        jj_consume_token(EXTERN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 114:
            jj_consume_token(114);
            s = extern_options();
            jj_consume_token(116);
            break;
        default:
            jj_la1[54] = jj_gen;
            ;
        }
        m_actions.processExternQual(s);
    }

    static final public String extern_options() throws ParseException {
        String s1, s2 = null;
        s1 = extern_option();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 115:
            jj_consume_token(115);
            s2 = extern_options();
            break;
        default:
            jj_la1[55] = jj_gen;
            ;
        }
        if (s2 == null) {
            {
                if (true)
                    return s1;
            }
        } else {
            {
                if (true)
                    return s1 + "," + s2;
            }
        }
        throw new Error("Missing return statement in function");
    }

    static final public String extern_option() throws ParseException {
        String s = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case ORDER:
            s = order_option();
            break;
        case DISPLAY:
        case EN:
        case FR:
            s = display_option();
            break;
        case ENABLED:
            s = enabled_option();
            break;
        default:
            jj_la1[56] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true)
                return s;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String order_option() throws ParseException {
        Token t1, t2;
        t1 = jj_consume_token(ORDER);
        jj_consume_token(112);
        t2 = jj_consume_token(INTEGER_LITERAL);
        {
            if (true)
                return t1.image + "=" + t2.image;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String display_option() throws ParseException {
        Token t1 = null;
        Token t2;
        String s;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case EN:
        case FR:
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case EN:
                t1 = jj_consume_token(EN);
                break;
            case FR:
                t1 = jj_consume_token(FR);
                break;
            default:
                jj_la1[57] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
            break;
        default:
            jj_la1[58] = jj_gen;
            ;
        }
        t2 = jj_consume_token(DISPLAY);
        jj_consume_token(112);
        s = string_literal_token();
        String display = t2.image;
        if (t1 != null) {
            display = t1.image + "_" + display;
        }

        {
            if (true)
                return display + "=" + s;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String enabled_option() throws ParseException {
        Token t;
        t = jj_consume_token(ENABLED);
        {
            if (true)
                return t.image;
        }
        throw new Error("Missing return statement in function");
    }

    static final public void false_qual() throws ParseException {
        String s;
        jj_consume_token(FALSE);
        jj_consume_token(112);
        s = identifier();
        m_actions.processFalseQual(s);
    }

    static final public void file_qual() throws ParseException {
        String s;
        jj_consume_token(FILE);
        jj_consume_token(112);
        s = identifier_or_literal();
        m_actions.processFileQual(s);
    }

    static final public void null_qual() throws ParseException {
        String s;
        jj_consume_token(NULL);
        jj_consume_token(112);
        s = identifier_or_literal();
        m_actions.processNullQual(s);
    }

    static final public void parm_qual() throws ParseException {
        String s;
        jj_consume_token(PARM);
        jj_consume_token(112);
        s = string_literal();
        m_actions.processParmQual(s);
    }

    static final public String pref_kw() throws ParseException {
        Token t;
        t = jj_consume_token(PREF);
        {
            if (true)
                return t.image;
        }
        throw new Error("Missing return statement in function");
    }

    static final public void pref_qual() throws ParseException {
        String pref, s;
        pref = pref_kw();
        jj_consume_token(112);
        s = identifier_or_literal();
        m_actions.processPrefQual(pref, s);
    }

    static final public void sep_qual() throws ParseException {
        String s;
        jj_consume_token(SEP);
        jj_consume_token(112);
        s = identifier_or_literal();
        m_actions.processSepQual(s);
    }

    static final public String suff_kw() throws ParseException {
        Token t;
        t = jj_consume_token(SUF);
        {
            if (true)
                return t.image;
        }
        throw new Error("Missing return statement in function");
    }

    static final public void suf_qual() throws ParseException {
        String suf, s;
        suf = suff_kw();
        jj_consume_token(112);
        s = identifier_or_literal();
        m_actions.processSufQual(suf, s);
    }

    static final public void true_qual() throws ParseException {
        String s;
        jj_consume_token(TRUE);
        jj_consume_token(112);
        s = identifier();
        m_actions.processTrueQual(s);
    }

    static final public void lower_qual() throws ParseException {
        jj_consume_token(LOWER);
        m_actions.processLowerQual();
    }

    static final public void upper_qual() throws ParseException {
        jj_consume_token(UPPER);
        m_actions.processUpperQual();
    }

    /*
     * INTEGER EXPRESSION
     */
    static final public IntegerModifier integer_expression() throws ParseException {
        IntegerModifier im = null;
        if (jj_2_1(3)) {
            im = atomic_integer_expression();
        } else if (jj_2_2(3)) {
            im = negation_operation();
        } else if (jj_2_3(3)) {
            im = addition_operation();
        } else if (jj_2_4(3)) {
            im = substraction_operation();
        } else if (jj_2_5(3)) {
            im = multiplication_operation();
        } else if (jj_2_6(3)) {
            im = division_operation();
        } else if (jj_2_7(3)) {
            im = length_operation();
        } else {
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true)
                return im;
        }
        throw new Error("Missing return statement in function");
    }

    static final public IntegerModifier atomic_integer_expression() throws ParseException {
        IntegerModifier im = null;
        if (jj_2_8(3)) {
            im = integer_variable();
        } else if (jj_2_9(3)) {
            im = integer_value();
        } else {
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true)
                return im;
        }
        throw new Error("Missing return statement in function");
    }

    static final public IntegerModifier negation_operation() throws ParseException {
        IntegerModifier im1 = null;
        jj_consume_token(118);
        im1 = integer_expression();
        IntegerModifier im2 = new IntegerModifier(IntegerModifier.INTEGER_NEGATION, im1);
        {
            if (true)
                return im2;
        }
        throw new Error("Missing return statement in function");
    }

    static final public IntegerModifier addition_operation() throws ParseException {
        IntegerModifier im1 = null, im2 = null;
        jj_consume_token(ADD);
        jj_consume_token(114);
        im1 = integer_expression();
        jj_consume_token(TO);
        im2 = integer_expression();
        jj_consume_token(116);
        IntegerModifier im = new IntegerModifier(IntegerModifier.INTEGER_ADDITION, im1, im2);
        {
            if (true)
                return im;
        }
        throw new Error("Missing return statement in function");
    }

    static final public IntegerModifier substraction_operation() throws ParseException {
        IntegerModifier im1 = null, im2 = null;
        jj_consume_token(SUBSTRACT);
        jj_consume_token(114);
        im1 = integer_expression();
        jj_consume_token(FROM);
        im2 = integer_expression();
        jj_consume_token(116);
        IntegerModifier im = new IntegerModifier(IntegerModifier.INTEGER_SUBSTRACTION, im1, im2);
        {
            if (true)
                return im;
        }
        throw new Error("Missing return statement in function");
    }

    static final public IntegerModifier multiplication_operation() throws ParseException {
        IntegerModifier im1 = null, im2 = null;
        jj_consume_token(MULTIPLY);
        jj_consume_token(114);
        im1 = integer_expression();
        jj_consume_token(BY);
        im2 = integer_expression();
        jj_consume_token(116);
        IntegerModifier im = new IntegerModifier(IntegerModifier.INTEGER_MULTIPLICATION, im1, im2);
        {
            if (true)
                return im;
        }
        throw new Error("Missing return statement in function");
    }

    static final public IntegerModifier division_operation() throws ParseException {
        IntegerModifier im1 = null, im2 = null;
        jj_consume_token(DIVIDE);
        jj_consume_token(114);
        im1 = integer_expression();
        jj_consume_token(PER);
        im2 = integer_expression();
        jj_consume_token(116);
        IntegerModifier im = new IntegerModifier(IntegerModifier.INTEGER_DIVISION, im1, im2);
        {
            if (true)
                return im;
        }
        throw new Error("Missing return statement in function");
    }

    static final public IntegerModifier length_operation() throws ParseException {
        String s;
        jj_consume_token(LENGTH);
        jj_consume_token(114);
        s = identifier();
        jj_consume_token(116);
        // IntegerModifier im = new
        // IntegerModifier(IntegerModifier.INTEGER_LENGTH, s);
        IntegerModifier im = m_actions.processIntegerLength(s);
        {
            if (true)
                return im;
        }
        throw new Error("Missing return statement in function");
    }

    static final public IntegerModifier integer_variable() throws ParseException {
        String s;
        jj_consume_token(INTEGER);
        jj_consume_token(114);
        s = identifier();
        jj_consume_token(116);
        IntegerModifier im = m_actions.processIntegerVariable(s);
        {
            if (true)
                return im;
        }
        throw new Error("Missing return statement in function");
    }

    static final public IntegerModifier integer_value() throws ParseException {
        Token t;
        t = jj_consume_token(INTEGER_LITERAL);
        IntegerModifier im = new IntegerModifier(t.image);
        {
            if (true)
                return im;
        }
        throw new Error("Missing return statement in function");
    }

    /*
     * BOOLEAN EXPRESSION
     */
    static final public BooleanModifier boolean_expression() throws ParseException {
        BooleanModifier bm = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case BOOLEAN:
        case FALSE:
        case INSTANCEOF:
        case TRUE:
            bm = atomic_boolean_expression();
            break;
        case NOT:
            bm = not_expression();
            break;
        case BOTH:
            bm = and_expression();
            break;
        case EITHER:
            bm = or_expression();
            break;
        case IF:
            bm = boolean_comparison();
            break;
        case CONTAINS:
        case ONLYCONTAINS:
        case STARTSWITH:
            bm = text_predicate();
            break;
        default:
            jj_la1[59] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true)
                return bm;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanModifier not_expression() throws ParseException {
        BooleanModifier bm1;
        jj_consume_token(NOT);
        jj_consume_token(114);
        bm1 = boolean_expression();
        jj_consume_token(116);
        BooleanModifier bm = m_actions.processNotExpression(bm1);
        {
            if (true)
                return bm;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanModifier and_expression() throws ParseException {
        BooleanModifier bm1, bm2;
        jj_consume_token(BOTH);
        jj_consume_token(114);
        bm1 = boolean_expression();
        jj_consume_token(AND);
        bm2 = boolean_expression();
        jj_consume_token(116);
        BooleanModifier bm = m_actions.processBooleanExpression(BooleanModifier.AND_OPERATION, bm1,
                bm2);
        {
            if (true)
                return bm;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanModifier or_expression() throws ParseException {
        BooleanModifier bm1, bm2;
        jj_consume_token(EITHER);
        jj_consume_token(114);
        bm1 = boolean_expression();
        jj_consume_token(OR);
        bm2 = boolean_expression();
        jj_consume_token(116);
        BooleanModifier bm = m_actions.processBooleanExpression(BooleanModifier.OR_OPERATION, bm1,
                bm2);
        {
            if (true)
                return bm;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanModifier text_predicate() throws ParseException {
        String pred, operand, var;
        pred = predicate();
        jj_consume_token(114);
        operand = predicate_operand();
        jj_consume_token(115);
        var = identifier();
        jj_consume_token(116);
        BooleanModifier bm = m_actions.processBooleanExpression(BooleanModifier.TEXT_PREDICATE,
                pred, operand, var);
        {
            if (true)
                return bm;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String predicate() throws ParseException {
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case CONTAINS:
            t = jj_consume_token(CONTAINS);
            break;
        case ONLYCONTAINS:
            t = jj_consume_token(ONLYCONTAINS);
            break;
        case STARTSWITH:
            t = jj_consume_token(STARTSWITH);
            break;
        default:
            jj_la1[60] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true)
                return t.image;
        }
        throw new Error("Missing return statement in function");
    }

    static final public String predicate_operand() throws ParseException {
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case LETTER_KW:
            t = jj_consume_token(LETTER_KW);
            break;
        case DIGIT_KW:
            t = jj_consume_token(DIGIT_KW);
            break;
        case LOWER:
            t = jj_consume_token(LOWER);
            break;
        case UPPER:
            t = jj_consume_token(UPPER);
            break;
        case UNDERSCORE:
            t = jj_consume_token(UNDERSCORE);
            break;
        default:
            jj_la1[61] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true)
                return t.image;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanModifier boolean_comparison() throws ParseException {
        Token t = null;
        IntegerModifier im1, im2;
        jj_consume_token(IF);
        jj_consume_token(114);
        im1 = integer_expression();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case 121:
            t = jj_consume_token(121);
            break;
        case 122:
            t = jj_consume_token(122);
            break;
        case 123:
            t = jj_consume_token(123);
            break;
        default:
            jj_la1[62] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        im2 = integer_expression();
        jj_consume_token(116);
        String s = t.image;
        int operation = 0;
        if (s.equals(">")) {
            operation = BooleanModifier.GREATER_THAN;
        } else if (s.equals("<")) {
            operation = BooleanModifier.LESS_THAN;
        } else if (s.equals("==")) {
            operation = BooleanModifier.EQUALS;
        } // end if

        BooleanModifier bm = m_actions.processBooleanExpression(operation, im1, im2);
        {
            if (true)
                return bm;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanModifier atomic_boolean_expression() throws ParseException {
        BooleanModifier bm = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
        case BOOLEAN:
            bm = boolean_variable();
            break;
        case TRUE:
            bm = boolean_true();
            break;
        case FALSE:
            bm = boolean_false();
            break;
        case INSTANCEOF:
            bm = instanceofClause();
            break;
        default:
            jj_la1[63] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true)
                return bm;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanModifier instanceofClause() throws ParseException {
        String s;
        jj_consume_token(INSTANCEOF);
        s = identifier_or_literal();
        BooleanModifier bm = m_actions.processInstanceOf(s);
        {
            if (true)
                return bm;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanModifier boolean_true() throws ParseException {
        jj_consume_token(TRUE);
        BooleanModifier bm = new BooleanModifier(true);
        {
            if (true)
                return bm;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanModifier boolean_false() throws ParseException {
        jj_consume_token(FALSE);
        BooleanModifier bm = new BooleanModifier(false);
        {
            if (true)
                return bm;
        }
        throw new Error("Missing return statement in function");
    }

    static final public BooleanModifier boolean_variable() throws ParseException {
        String s;
        jj_consume_token(BOOLEAN);
        jj_consume_token(114);
        s = identifier();
        jj_consume_token(116);
        BooleanModifier bm = m_actions.processBooleanVariable(s);
        {
            if (true)
                return bm;
        }
        throw new Error("Missing return statement in function");
    }

    static final private boolean jj_2_1(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_1();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(0, xla);
        }
    }

    static final private boolean jj_2_2(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_2();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(1, xla);
        }
    }

    static final private boolean jj_2_3(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_3();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(2, xla);
        }
    }

    static final private boolean jj_2_4(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_4();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(3, xla);
        }
    }

    static final private boolean jj_2_5(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_5();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(4, xla);
        }
    }

    static final private boolean jj_2_6(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_6();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(5, xla);
        }
    }

    static final private boolean jj_2_7(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_7();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(6, xla);
        }
    }

    static final private boolean jj_2_8(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_8();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(7, xla);
        }
    }

    static final private boolean jj_2_9(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_9();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(8, xla);
        }
    }

    static final private boolean jj_3R_12() {
        if (jj_scan_token(IDENTIFIER))
            return true;
        return false;
    }

    static final private boolean jj_3_7() {
        if (jj_3R_8())
            return true;
        return false;
    }

    static final private boolean jj_3R_6() {
        if (jj_scan_token(MULTIPLY))
            return true;
        if (jj_scan_token(114))
            return true;
        if (jj_3R_11())
            return true;
        return false;
    }

    static final private boolean jj_3_6() {
        if (jj_3R_7())
            return true;
        return false;
    }

    static final private boolean jj_3_5() {
        if (jj_3R_6())
            return true;
        return false;
    }

    static final private boolean jj_3_4() {
        if (jj_3R_5())
            return true;
        return false;
    }

    static final private boolean jj_3_3() {
        if (jj_3R_4())
            return true;
        return false;
    }

    static final private boolean jj_3_2() {
        if (jj_3R_3())
            return true;
        return false;
    }

    static final private boolean jj_3_1() {
        if (jj_3R_2())
            return true;
        return false;
    }

    static final private boolean jj_3R_10() {
        if (jj_scan_token(INTEGER_LITERAL))
            return true;
        return false;
    }

    static final private boolean jj_3R_11() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_1()) {
            jj_scanpos = xsp;
            if (jj_3_2()) {
                jj_scanpos = xsp;
                if (jj_3_3()) {
                    jj_scanpos = xsp;
                    if (jj_3_4()) {
                        jj_scanpos = xsp;
                        if (jj_3_5()) {
                            jj_scanpos = xsp;
                            if (jj_3_6()) {
                                jj_scanpos = xsp;
                                if (jj_3_7())
                                    return true;
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    static final private boolean jj_3R_5() {
        if (jj_scan_token(SUBSTRACT))
            return true;
        if (jj_scan_token(114))
            return true;
        if (jj_3R_11())
            return true;
        return false;
    }

    static final private boolean jj_3R_9() {
        if (jj_scan_token(INTEGER))
            return true;
        if (jj_scan_token(114))
            return true;
        if (jj_3R_12())
            return true;
        return false;
    }

    static final private boolean jj_3R_4() {
        if (jj_scan_token(ADD))
            return true;
        if (jj_scan_token(114))
            return true;
        if (jj_3R_11())
            return true;
        return false;
    }

    static final private boolean jj_3R_8() {
        if (jj_scan_token(LENGTH))
            return true;
        if (jj_scan_token(114))
            return true;
        if (jj_3R_12())
            return true;
        return false;
    }

    static final private boolean jj_3R_3() {
        if (jj_scan_token(118))
            return true;
        if (jj_3R_11())
            return true;
        return false;
    }

    static final private boolean jj_3R_7() {
        if (jj_scan_token(DIVIDE))
            return true;
        if (jj_scan_token(114))
            return true;
        if (jj_3R_11())
            return true;
        return false;
    }

    static final private boolean jj_3_9() {
        if (jj_3R_10())
            return true;
        return false;
    }

    static final private boolean jj_3_8() {
        if (jj_3R_9())
            return true;
        return false;
    }

    static final private boolean jj_3R_2() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_8()) {
            jj_scanpos = xsp;
            if (jj_3_9())
                return true;
        }
        return false;
    }

    static private boolean jj_initialized_once = false;
    static public TemplateParserTokenManager token_source;
    static JavaCharStream jj_input_stream;
    static public Token token, jj_nt;
    static private int jj_ntk;
    static private Token jj_scanpos, jj_lastpos;
    static private int jj_la;
    static public boolean lookingAhead = false;
    static private boolean jj_semLA;
    static private int jj_gen;
    static final private int[] jj_la1 = new int[64];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;
    static private int[] jj_la1_2;
    static private int[] jj_la1_3;
    static {
        jj_la1_0();
        jj_la1_1();
        jj_la1_2();
        jj_la1_3();
    }

    private static void jj_la1_0() {
        jj_la1_0 = new int[] { 0x0, 0x20000000, 0x20000000, 0x10100000, 0x0, 0x0, 0x0, 0xcee80000,
                0x40000, 0x40000, 0x10140800, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40000, 0x40000,
                0x40000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0x40000, 0x10140800, 0x40000, 0x0, 0x800, 0x0,
                0x800, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x100000, 0x0, 0x0, 0x0,
                0x100000, };
    }

    private static void jj_la1_1() {
        jj_la1_1 = new int[] { 0x80000000, 0x0, 0x0, 0x800001, 0x800000, 0x1000000, 0x0, 0x400010e,
                0x0, 0x0, 0x21044629, 0x0, 0x8000, 0x80, 0x8000, 0x8000, 0x0, 0x0, 0x0, 0x800,
                0x800, 0x0, 0x0, 0x0, 0x1000000, 0x0, 0x0, 0x0, 0x0, 0x40000080, 0x0, 0x40000080,
                0x0, 0x0, 0x20000, 0x20000, 0x10000000, 0x800000, 0x0, 0x800000, 0x800000, 0x0,
                0x800, 0x0, 0x21044629, 0x201, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2808000, 0x2808000,
                0x2808000, 0x0, 0x0, 0x8602000, 0x8200000, 0x8200000, 0x21040420, 0x400, 0x1000,
                0x0, 0x1000000, };
    }

    private static void jj_la1_2() {
        jj_la1_2 = new int[] { 0x0, 0x0, 0x0, 0x10, 0x0, 0x20000000, 0x0, 0x0, 0x0, 0x0,
                0x383004c6, 0x0, 0x408120, 0x0, 0x408120, 0x408120, 0x200, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x488100, 0x20000000, 0x0, 0x488100, 0x488100, 0x0, 0x0, 0x0, 0x488100, 0x0,
                0x488100, 0x488100, 0x80000000, 0x80000000, 0x1, 0x488100, 0x0, 0x488100, 0x488100,
                0x0, 0x100, 0x0, 0x383004c6, 0x18000000, 0x18000000, 0x0, 0x0, 0x0, 0x0, 0x408120,
                0x408120, 0x408120, 0x0, 0x0, 0x1000, 0x0, 0x0, 0x20100482, 0x100400, 0x40000028,
                0x0, 0x20000002, };
    }

    private static void jj_la1_3() {
        jj_la1_3 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2000, 0x0, 0x0, 0x2000, 0x402000,
                0x80000, 0x80001, 0x0, 0x1, 0x1, 0x0, 0x40000, 0x2000, 0x40000, 0x0, 0x80000, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x80000, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x80000, 0x0, 0x0, 0x40000, 0x0, 0x2000, 0x402000, 0x2000, 0x0, 0x42000, 0x1e00000,
                0x2000, 0x1e00000, 0x1, 0x1, 0x1, 0x40000, 0x80000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,
                0xe000000, 0x0, };
    }

    static final private JJCalls[] jj_2_rtns = new JJCalls[9];
    static private boolean jj_rescan = false;
    static private int jj_gc = 0;

    public TemplateParser(java.io.InputStream stream) {
        this(stream, null);
    }

    public TemplateParser(java.io.InputStream stream, String encoding) {
        if (jj_initialized_once) {
            System.out.println("ERROR: Second call to constructor of static parser.  ");
            System.out
                    .println("       You must either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("       during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        try {
            jj_input_stream = new JavaCharStream(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new TemplateParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 64; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    static public void ReInit(java.io.InputStream stream) {
        ReInit(stream, null);
    }

    static public void ReInit(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 64; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    public TemplateParser(java.io.Reader stream) {
        if (jj_initialized_once) {
            System.out.println("ERROR: Second call to constructor of static parser. ");
            System.out
                    .println("       You must either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("       during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        jj_input_stream = new JavaCharStream(stream, 1, 1);
        token_source = new TemplateParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 64; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    static public void ReInit(java.io.Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 64; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    public TemplateParser(TemplateParserTokenManager tm) {
        if (jj_initialized_once) {
            System.out.println("ERROR: Second call to constructor of static parser. ");
            System.out
                    .println("       You must either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("       during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 64; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    public void ReInit(TemplateParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 64; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    static final private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            if (++jj_gc > 100) {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++) {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null) {
                        if (c.gen < jj_gen)
                            c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    static private final class LookaheadSuccess extends java.lang.Error {
    }

    static final private LookaheadSuccess jj_ls = new LookaheadSuccess();

    static final private boolean jj_scan_token(int kind) {
        if (jj_scanpos == jj_lastpos) {
            jj_la--;
            if (jj_scanpos.next == null) {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
            } else {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan) {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos) {
                i++;
                tok = tok.next;
            }
            if (tok != null)
                jj_add_error_token(kind, i);
        }
        if (jj_scanpos.kind != kind)
            return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos)
            throw jj_ls;
        return false;
    }

    static final public Token getNextToken() {
        if (token.next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    static final public Token getToken(int index) {
        Token t = lookingAhead ? jj_scanpos : token;
        for (int i = 0; i < index; i++) {
            if (t.next != null)
                t = t.next;
            else
                t = t.next = token_source.getNextToken();
        }
        return t;
    }

    static final private int jj_ntk() {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    static private java.util.Vector jj_expentries = new java.util.Vector();
    static private int[] jj_expentry;
    static private int jj_kind = -1;
    static private int[] jj_lasttokens = new int[100];
    static private int jj_endpos;

    static private void jj_add_error_token(int kind, int pos) {
        if (pos >= 100)
            return;
        if (pos == jj_endpos + 1) {
            jj_lasttokens[jj_endpos++] = kind;
        } else if (jj_endpos != 0) {
            jj_expentry = new int[jj_endpos];
            for (int i = 0; i < jj_endpos; i++) {
                jj_expentry[i] = jj_lasttokens[i];
            }
            boolean exists = false;
            for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
                int[] oldentry = (int[]) (e.nextElement());
                if (oldentry.length == jj_expentry.length) {
                    exists = true;
                    for (int i = 0; i < jj_expentry.length; i++) {
                        if (oldentry[i] != jj_expentry[i]) {
                            exists = false;
                            break;
                        }
                    }
                    if (exists)
                        break;
                }
            }
            if (!exists)
                jj_expentries.addElement(jj_expentry);
            if (pos != 0)
                jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    static public ParseException generateParseException() {
        jj_expentries.removeAllElements();
        boolean[] la1tokens = new boolean[124];
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 64; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                    if ((jj_la1_2[i] & (1 << j)) != 0) {
                        la1tokens[64 + j] = true;
                    }
                    if ((jj_la1_3[i] & (1 << j)) != 0) {
                        la1tokens[96 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 124; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = (int[]) jj_expentries.elementAt(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    static final public void enable_tracing() {
    }

    static final public void disable_tracing() {
    }

    static final private void jj_rescan_token() {
        jj_rescan = true;
        for (int i = 0; i < 9; i++) {
            try {
                JJCalls p = jj_2_rtns[i];
                do {
                    if (p.gen > jj_gen) {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;
                        switch (i) {
                        case 0:
                            jj_3_1();
                            break;
                        case 1:
                            jj_3_2();
                            break;
                        case 2:
                            jj_3_3();
                            break;
                        case 3:
                            jj_3_4();
                            break;
                        case 4:
                            jj_3_5();
                            break;
                        case 5:
                            jj_3_6();
                            break;
                        case 6:
                            jj_3_7();
                            break;
                        case 7:
                            jj_3_8();
                            break;
                        case 8:
                            jj_3_9();
                            break;
                        }
                    }
                    p = p.next;
                } while (p != null);
            } catch (LookaheadSuccess ls) {
            }
        }
        jj_rescan = false;
    }

    static final private void jj_save(int index, int xla) {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen) {
            if (p.next == null) {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    static final class JJCalls {
        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
