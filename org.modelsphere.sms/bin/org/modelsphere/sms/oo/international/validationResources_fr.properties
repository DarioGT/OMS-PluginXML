/*************************************************************************

Copyright (C) 2009 Grandite

This file is part of Open ModelSphere.

Open ModelSphere is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
or see http://www.gnu.org/licenses/.

You can redistribute and/or modify this particular file even under the
terms of the GNU Lesser General Public License (LGPL) as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

You should have received a copy of the GNU Lesser General Public License 
(LGPL) along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
or see http://www.gnu.org/licenses/.

You can reach Grandite at: 

20-1220 Lebourgneuf Blvd.
Quebec, QC
Canada  G2K 2G4

or

open-modelsphere@grandite.com

**********************************************************************/

AbstractMethod0CantBody=méthode abstraite {0} ne peut avoir de corps : la méthode d \'une interface est implicitement abstraite.<br>
Abstract0Method1CantBody={0} méthode {1} ne peut avoir de corps : la méthode {0} ne peut donner une implémentation.<br>
Adt0CannotSameNameAsEnclosingClass1Encladt2={0} ne peut avoir le même nom que son inclus {1} {2}.<br>
AdtErrorTitle=<br><font color=\"#ff0000\">{0} {1}</font><br>
ACyclicInheritanceInvolvingXxx0_Xxx1_Xxx2=héritage cyclique impliquant {0} {1} : un {2}
AnCyclicInheritanceInvolvingXxx0_Xxx1_Xxx2=héritage cyclique impliquant {0} {1} : un {2}
AllConstrSuperclassXxx0HaveThrows=tous les constructeurs de super-classes {0} ont une clause de génération d \'exception.<br>
AMethod0OfInterfaceIsPublic=&nbsp Un {0} d\'une interface est implicitement publique.<br>
AnMethod0OfInterfaceIsPublic=&nbsp Un {0} d\'une interface est implicitement publique.<br>
AXxx0DupCompilNamesXxx1_Xxx2=le nom de l\'unité de compilation {0} est réutilisé {1} fois : un {2}
AnXxx0DupCompilNamesXxx1_Xxx2=le nom de l\'unité de compilation {0} est réutilisé {1} fois : un {2}
AXxx0DupCompilNameXxx1_Xxx2=le nom de l\'unité de compilation {0} est réutilisé {1} fois : un {2}
AnXxx0DupCompilNameXxx1_Xxx2=le nom de l\'unité de compilation {0} est réutilisé {1} fois : un {2}
AXxx0DupFNamesXxx1_Xxx2=le nom du champ {1} est réutilisé {0} fois : une {2}
AnXxx0DupFNamesXxx1_Xxx2=le nom du champ {1} est réutilisé {0} fois : une {2}
AXxx0DupFNameXxx1_Xxx2=le nom du champ {1} est réutilisé {0} fois : une {2}
AnXxx0DupFNameXxx1_Xxx2=le nom du champ {1} est réutilisé {0} fois : une {2}
AXxx0DupCINamesXxx1_Xxx2=le nom du classificateur {1} est réutilisé {0} fois : une {2}
AnXxx0DupCINamesXxx1_Xxx2=le nom du classificateur {1} est réutilisé {0} fois : une {2}
AXxx0DupCINameXxx1_Xxx2=le nom du classificateur {1} est réutilisé {0} fois : une {2}
AnXxx0DupCINameXxx1_Xxx2=le nom du classificateur {1} est réutilisé {0} fois : une {2}
AXxx0DupMethods1SigXxx2_Xxx3={0} signatures de {1} de trop sur {2} : une {3}
AnXxx0DupMethods1SigXxx2_Xxx3={0} signatures de {1} de trop sur {2} : une {3}
AXxx0DupMethod1SigXxx2_Xxx3={0} signature de {1} de trop sur {2} : une {3}
AnXxx0DupMethod1SigXxx2_Xxx3={0} signature de {1} de trop de {2} : une {3}
AtSameLevel =&nbsp au même niveau
CannotExtendClassXxx0=ne peut hériter de la classe {0} : la classe {1} est déclarée finale et ne peut pas avoir de sous-classes.<br>
CannotBeAllTogetherSuperclasses=&nbsp ne peuvent pas toutes être des super-classes directes.<br>
CannotImplement0DirectlyInterfaceXxx1MoreOneTime=ne peut pas {0} directement l'interface {1} plus d'une fois.<br>
CannotInheritClassXxx0=ne peut pas hériter de la classe {0} : une interface peut hériter des interfaces seulement.<br>
CannotInheritFromClass0Xxx1VisErr2=ne peut pas hériter de {1}. {2}<br>
CannotInheritFromInnerClassXxx0=&nbsp ne peut pas hériter d\'un de ses {0} internes.<br>
CannotInheritFromNestedAdtXxx0=&nbsp ne peut hériter d\'un de ses {0} imbriqué.<br>
CannotInheritMoreOneSuperclass=ne peut pas hériter de plus d\'une super-classe directe à la fois :&nbsp
CannotHaveTwoFieldsSameName=&nbsp ne peut pas avoir deux champs ou plus portant le même nom.<br>
CannotHaveTwoMemberCISameName=&nbsp ne peut pas avoir deux classes/interfaces membres ou plus portant le même nom.<br>
CannotHaveTwoMethod0sSameSignature=&nbsp ne peut pas avoir plus d\'un/une {0} avec la même signature.<br>
CannotSameNameClassInSameContainer0=&nbsp ne peut pas avoir le même nom qu\'un autre classificateur dans la même {0}.<br>
CannotSameNameCompilInSameContainer0=&nbsp ne peut pas avoir une unité de compilation avec le même nom que n\'importe quelle autre unité de compilation déclarée dans le même {0}.<br>
CantHide0MethodXxx1Xxx2InXxx3Xxx4DifferentRettype=&nbsp ne peut pas {0} la méthode {1} {2} de {4} avec un différent type de retour.<br>
CantXxx0Xxx1Method2InXxx3Xxx4WeakerPrivilege5=&nbsp ne peut pas {0} <i>{1}</i> une méthode {2} de {4} avec de faible droit d\'accès{5}
Class0CannotBeVis1={0} ne peut pas être déclarée {1} :
Class0Encladt1CannotBeAccessed={0} <i>{1}</i> ne peut pas être accédée :
ClassCannotBeFinalAbstract=la classe ne peut pas être déclarée finale et abstraite : une classe finale ne peut pas être sous-classée.<br>
ClassCantBeNotAbstractAndNotImplementAbstractMethod0InXxx1Xxx2=la classe ne peut pas être abstraite ni implémenter des méthodes abstraites {0} de {2}.<br>
ClassCantNotAbstractContainsAbstracMethod0=une classe ne peut pas être abstraite ni contenir des méthodes abstraites {0} : la déclaration d'une méthode abstraite doit apparaître à l\'intérieur d'une classe abstraite.<br>
ClassesInterfacesCircularity=<font color=\"#ff0000\">Classes/Interfaces Circularité:</font><br>
Constr0InvalidName=le constructeur {0} a un nom invalide : le constructeur doit avoir le même nom que la classe.<br>
CyclicInheritanceByThePath=héritage cyclique par le chemin&nbsp
DbObjectHyperLink=<a href=\"{0}:{1}\">{2}</a>
DupParamXxx0InMethod1Xxx2Xxx1=le nom du paramètre en double {0} de {2} : un/une {1} ne peut pas avoir deux paramètres formels portant le même nom.<br>
DotReturn=.<br>
EnclosingClass0Encladt1=&nbsp inclus {0} <i>{1}</i>
ErrorNbr0=<b>&nbsp ** Erreur ({0}) - </b>
Extend=étendre
FieldXxx0CantNoType=le type du champ {0} doit être spécifié.<br>
FieldXxx0CantXxx1Xxx2AsTypeVis3=le champ {0} ne peut pas avoir {1} {2} comme type. {3}<br>
FieldXxx0CantFinalVolatile=le champ {0} ne peut pas être déclaré final et volatile.<br>
FieldXxx0CantVis1_InterfaceFieldImplicitlyPublic=le champ {0} ne peut pas être déclaré {1} : le champ d'une interface est implicitement public.<br>
FieldXxx0CantTransient_InterfaceFieldImplicitlyStatic=le champ {0} ne peut pas être déclaré transient : le champ d'une interface est implicitement statique.<br>
FieldXxx0CantVolatile_InterfaceFieldImplicitlyFinal=le champ {0} ne peut pas être déclaré volatile : le champ d'une interface est implicitement final.<br>
Hide=cache
Hidden=caché
Implement=implémente
InheritedFromMethod0Xxx1=&nbsp (hérité de {0} {1})&nbsp
InPackageXxx0=&nbsp dans un paquetage {0}
InProjetXxx0=&nbsp dans un projet {0}
InvalidConstDecls=déclarations de constructeur invalides :&nbsp
InvalidConstDecl=déclaration de constructeur invalide :&nbsp
InterfaceCantHaveConstr=. Une interface ne peut pas avoir de déclarations de constructeur.<br>
InterfaceMethodIsPublic= : une méthode d'interface est implicitement publique.<br>
It=&nbsp il
JavaErrors=<h1><Erreur(s) Java<br></h1>
JavaValidation=Validation Java
Method0Cant1=la méthode {0} ne peut être déclarée {1} : une méthode d'interface est implicitement publique.<br>
Method0CantFinal=la méthode {0} ne peut être déclarée finale : une méthode d\'interface est implicitement abstraite.<br>
Method0CantFinalAbstract=la méthode {0} ne peut être déclarée finale et abstraite : une méthode finale ne peut être redéfinie.<br>
Method0CantHaveXxx1Xxx2ReturnType_Xxx3=la méthode {0} ne peut avoir {1} {2} comme type de retour. {3}<br>
Method0CantNative=la méthode {0} ne peut être déclarée native : une méthode d\'interface est implicitement abstraite.<br>
Method0CantNatAbstract=la méthode {0} ne peut être déclarée native et abstraite : le mot de passe natif décrit une propriété d\'implémentation.<br>
Method0CantPrivateAbstract=la méthode {0} ne peut pas être déclarée privée et abstraite : une méthode privée ne peut être redéfinie.<br>
Method0CantStatic=la méthode {0} ne peut pas être déclarée statique : une méthode d'interface est implicitement abstraite.<br>
Method0CantStatAbstract=la méthode {0} ne peut pas être déclarée statique et abstraite : une méthode statique ne peut être redéfinie.<br>
Method0CantSynchronized=la méthode {0} ne peut pas être déclarée synchronisée : une méthode d'interface est implicitement abstraite.<br>
Method0CantSyncAbstract=la méthode {0} ne peut pas être déclarée synchronisée et abstraite : un mot de passe synchronisé décrit une propriété d'implémentation.<br>
Method0Xxx1CantStatic_InnerCantStaticMembers={0}{1} ne peut pas être déclarée statique : une classe interne ne peut pas avoir de membres statiques.<br>
Method0Xxx1CantXxx2FinalMethodXxx3InClass4_CantBe5=la méthode {0}{1} ne peut pas {2} une méthode finale {3} dans la classe {4} : la méthode finale d'une classe ne peut pas être {5}.<br>
Method0Yyy1CantXxx2Xxx3InXxx4Xxx5_Xxx6MethodNotThrowExc7=&nbsp la méthode {0}{1} ne peut pas {2} la méthode {3} de {5} : la méthode {6} ne génère pas l'exception {7} ou l'une de ses super-classes.<br>
methodRettype0Xxx1=la méthode {0} {1}
ModelClosed=L'objet ne peut être trouvé parce que le modèle référé par ce lien a été fermé.
MustBePublic_Class0CannotBeVis1=&nbsp {0} ne peut être déclaré {1} : il ne peut qu\'être déclaré public ou paquetage (accès par défaut).<br>
Name=nom
Names=noms
Native0Method1CantBody={0} méthode {1} ne peut pas avoir de corps : une {0} méthode ne peut donner une implémentation.<br>
NestedTopClass0CannotBeInInnerXxx1={0} imbriquée au niveau supérieur ne peut être déclarée dans une classe interne {1} : elles ne peuvent qu\'être imbriquées dans d'autres classes ou interfaces de niveau supérieur.<br>
Nb0DupAttr1NameAttr1=le nom de {1} est réutilisé {0} fois : une {1}
Nb0DupAttr1NamesAttr1=le nom de {1} est réutilisé {0} fois : une {1}
Nb0DupClas1NameClas1=le nom de {1} est réutilisé {0} fois : une {1}
Nb0DupClas1NamesClas1=le nom de {1} est réutilisé {0} fois : une {1}
NoJavaErrors=<br>&nbsp&nbsp&nbsp <b>Aucune Erreur Java</b><br>
NotPossibleProvideConstructor_Superclass0NoConstr1WithoutNoParam=impossible de donner un constructeur par défaut : la super-classe {0} n'a pas de constructeur {1}() sans aucun paramètres.<br>
NotStaticMethod0Xxx1CantOverrideStaticMethod2InXxx3=une méthode non statique {0}{1} ne peut pas redéfinir une méthode statique {2} dans la classe {3} : une méthode d'instance ne peut pas redéfinir une méthode statique.<br>
ObjectNotFoundInDb=Objet non trouvé. Il doit avoir été supprimé ou fermé.
OperationXxx0_Xxx1CantThrowsXxx2_Xxx2Exception_Xxx3={0} {1} ne peut pas lancer {2} {3}. {4}<br>
Override=redéfinir
Overridden=redéfinie
PathEnum=&nbsp -
Return=<br>
S2ParamXxx0InClass1Xxx2CantXxx3Xxx4Type=paramètre {0} de {2} ne peut pas avoir {3} {4} comme type. {5}<br>
StaticMethod0Xxx1CantHideNotStaticMethod2InXxx3Xxx4=une méthode statique {0}{1} ne peut pas cacher une méthode non statique {2} de {4} : une méthode statique ne peut pas cacher une méthode d\'instance.<br>
Package0Class1CannotBeStatic={0} {1} ne peut pas être déclaré statique : seule une classe/interface imbriquée peut être déclarée statique.<br>
PackageVisible=paquetage visible
ParamXxx0InClass1Xxx2CantNoType=le type du paramètre {0} (du/de la) {1} {2} doit être spécifié.<br>
UnrepExInConstrs=exception non signalée dans les déclarations de constructeur:&nbsp
UnrepExInConstr=exception non signalée dans la déclaration de constructeur:&nbsp
Visibility0Method1=<i>{0}</i> méthode {1}
Void=<i>sans type de retour</i>
Xxx0Xxx1IsDeclaredVis2Where3={0}{1} est déclaré {2} {3}.

